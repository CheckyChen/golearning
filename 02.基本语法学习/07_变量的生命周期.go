package _2_基本语法学习

import "fmt"

// 1、栈，只允许往线性表的一端放入数据，之后在这端取出数据，先进先出(LIFO)
// 	 入栈：往栈中放入元素的过程叫做入栈。入栈会增加栈的元素数量，最后放入的元素总是位于栈的顶部，最先放入的元素总是位于栈的底部
//	 出栈：从栈中取出元素时，只能从栈顶部取出。取出元素后，栈的数量会变少。最先放入的元素总是最后被取出，最后放入的元素总是最先被取出。
//	       不允许从栈底获取数据，也不允许对栈成员（除栈顶外的成员）进行任何查看和修改操作。

// 栈可以用于分配内存，栈的分配和回收速度非常快。

//2、堆，堆在内存分配中类似于往一个房间里摆放各种家具，家具的尺寸有大有小。分配内存时，需要找一块足够装下家具的空间再摆放家具。
//   经过反复摆放和腾空家具后，房间里的空间会变得乱七八糟，此时再往空间里摆放家具会存在虽然有足够的空间，但各空间分布在不同的区域，
//   无法有一段连续的空间来摆放家具的问题

// 堆分配内存和栈分配内存相比，堆适合不可预知大小的内存分配。但是为此付出的代价是分配速度较慢，而且会形成内存碎片。

// 3、变量逃逸（Escape Analysis）----自动决定变量分配方式，提高运行效率
//    Go 语言将这个过程整合到编译器中，命名为“变量逃逸分析”。这个技术由编译器分析代码的特征和代码生命期，决定应该如何堆还是栈进行内存分配，
//    即使程序员使用 Go 语言完成了整个工程后也不会感受到这个过程。

// 1）逃逸分析
func dummy(b int) int {
	var c int
	c = b
	return c
}

func void() {}

// 2）取地址发生逃逸

// 声明一个空的结构体做结构体逃逸分析。
type Data struct{}

func dummy1() *Data {
	//将 c 变量声明为 Data 类型，此时 c 的结构体为值类型。
	var c Data
	//取函数局部变量 c 的地址并返回。Go 语言的特性允许这样做。
	return &c
}

//3) 原则
//	在使用 Go 语言进行编程时，Go 语言的设计者不希望开发者将精力放在内存应该分配在栈还是堆上的问题。
//  编译器会自动帮助开发者完成这个纠结的选择。但变量逃逸分析也是需要了解的一个编译器技术，这个技术不仅用于 Go 语言，
//  在 Java 等语言的编译器优化上也使用了类似的技术。
//
//编译器觉得变量应该分配在堆和栈上的原则是：
//变量是否被取地址。
//变量是否发生逃逸。

func main() {
	//var a int
	//void()
	//fmt.Println(a, dummy(0))
	// 输出
	//	# command-line-arguments
	//.\07_变量的生命周期.go:35:13: a escapes to heap //a逃逸到堆
	//.\07_变量的生命周期.go:35:22: dummy(0) escapes to heap //dummy(0)逃逸到堆
	//.\07_变量的生命周期.go:35:13: main ... argument does not escape
	//0 0

	fmt.Println(dummy1())
	// 输出
	//# command-line-arguments
	//.\07_变量的生命周期.go:36:9: &c escapes to heap
	//.\07_变量的生命周期.go:35:6: moved to heap: c
	//.\07_变量的生命周期.go:50:20: dummy1() escapes to heap
	//.\07_变量的生命周期.go:50:13: main ... argument does not escape
	//&{}

}
